# 4.median-of-two-sorted-arrays 两个排序数组的中位数

### 分析

- 要做出这道题，要对中位数的含义有较深刻的理解，中位数实际上是对一组数的划分：

  1. 这一组数被划分为个数相同（或差一）的两组数

  2. 被划分的两组数中，偏小的一组数的最大值应该不大于另一组数的最小值

- 虽然题目中给出的是两个数组A、B，我们依旧可以将这两个数组分别再划分成两组数组，以下标i为A中划分的位置，下标j为B中划分的位置，则最终的划分应该如下：

  ```c++
  A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]
  B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1]
  ```

- 根据我们的第一点总结，我们可以根据划分的两组数的个数的到i和j的关系为`i + j == m - i + n - j`
- 根据我们的第二点总结，在有序数组中，应该满足`A[i-1] <= B[j] && B[j-1] <= A[i]`
- 这样问题就被转为了在有序数组A中寻找这样一个i，`0 <= i <= m`，使得以上的不等式满足
- 由于是在有序数组中查找，我们很自然地会去想是否可以用二分查找，那么在二分查找时会有什么样的情况呢：
  1. `A[i-1] <= B[j] && B[j-1] <= A[i]`：说明我们找到了符合要求的i；
  2. `A[i-1] > B[j]`：说明此时的i太大，只有让i小一点才能让`A[i-1]`小一点、`B[i-1]`大一点而满足不等式。那么我们就需要将二分查找的右边界设为`i-1`；
  3. `B[j-1] > A[i]`：说明此时的i太小。同上的分析，我们将二分查找的左边界设为`i+1`；
- 对于边界条件：`i = 0\ i = m\ j = 0\ j = n`，其实表示两组数组已经是划分好的结果，那这样我们就不要再去二分搜索了，所以二分搜索时只需要对这些以外的情况进行搜索就好了



### 容易疑惑的地方

- 在用i表示j的时候，网上有两种写法：
  - `j = (m + n + 1) / 2 - i`
  - `j = (m + n) / 2 - i`

- 区别在于有没有加一，这其实与m、n之和的奇偶有关系

- 当`m + n`是奇数时，我们实际上划分的两组数的个数是不等的

- 当有“+1”时，偏小的一侧会比右侧多一个数字（i = 2时j = 2）：

  ```c++
  A[0], A[1] | A[2], A[3]
  B[0], B[1] | B[2]
  ```

  - 所以中位数是左边最大值

- 当没有“+1”时，偏小的一侧会比右侧多一个数字（i = 2时j =1）：

  ```c++
  A[0], A[1] | A[2], A[3]
  	  B[0] | B[1], B[2] 
  ```

  - 所以中位数时右边最小值

