# 41.first-missing-positive 最小的缺失正整数

### 思路

- 题目提示时间复杂度是O(n)，空间复杂度是常数；所以只能对数组进行顺序遍历，且只能使用常数的空间，因此我们考虑在原数组上进行哈希。
- 返回的结果应该在[1, 数组长度 + 1]这样一个范围里
- 对于数组中每个位置，我们将位置上的数放到下标为该数字减一的位置，在所有的数都被放到合适的位置之后数组中实际是有两类数：
  1. 小于等于数组长度的正整数：被放置到数字减一的下标处 ，如nums[1] = 2
  2. 零和负数 & 大于数组长度的正整数：它们类似于数组的缺陷，我们要找的就是第一个缺陷
- 移动每个数的前提有三点：
  - 首先要大于零：小于零没办法取下标；等于零就是一个缺失的位置。
  - 该数字也不能大于数组的长度，没办法取下标
  - 如果存在重复的数，那么合适的位置可能已经放上了对应的数，所以只有位置上的数不同时才能移动，不然就会死循环
- 最后返回的就是第一个缺陷，每个正整数已被放在合适的位置；没有缺陷的话则是数组长度加一。