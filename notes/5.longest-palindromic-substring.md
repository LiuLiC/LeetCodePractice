# 5.longest-palindromic-substring 最长回文子串

### 思路

-  使用动态规划思路，对于一个子串s，它是否为回文串可以转化为一个二元函数的表示*f(i, j)*：
  1. 若i == j，则该子串只有一个字符，一定是回文串；
  2. 若i != j，则可以判断s[i]是否等于s[j]，若不等于则肯定不是回文串，若s[i] == s[j]，则去检查内部的子串是否为回文串，也就是*f(i+1, j-1)*是否为真。
-  使用一个二维数组dp来存储以上二元函数的数值，将dp数组对角线初始化为true，其余为false；



### 注意

- 对二维数组dp的遍历是在数组的右上角逐列进行的：
  - 只对右上角遍历是因为要保证j大于i，避免重复；
  - 逐列是因为动态规划中需要用到以前计算过的结果，即字符串内部子串的对称性。如果逐行的话则不会有内部子串的信息了；
  - 对边界条件，需要满足i+1，j-1在有效范围内，且只对长度大于2的串检查其内部，等于2的在判断两端是否相等时就可以得到结果了。